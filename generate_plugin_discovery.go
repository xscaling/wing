//go:build ignore

package main

import (
	"bufio"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
)

const (
	pluginPath             = "github.com/xscaling/wing/plugins/"
	pluginFile             = "plugin.conf"
	pluginFSPath           = "plugins/" // Where the plugins are located on the file system
	header                 = "// generated by plugin_generate.go; DO NOT EDIT\n\n"
	scalerFlagLine         = ">>> Scaler"
	metricProviderFlagLine = ">>> Metric Provider"
)

func main() {
	pluginsMapping := map[string]map[string]string{
		"metric_provider": make(map[string]string),
		"scaler":          make(map[string]string),
	}

	file, err := os.Open(pluginFile)
	if err != nil {
		log.Fatalf("Failed to open %s: %q", pluginFile, err)
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)
	flag := ""
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") {
			continue
		}

		// Check flag line first
		if line == scalerFlagLine {
			flag = "scaler"
			continue
		} else if line == metricProviderFlagLine {
			flag = "metric_provider"
			continue
		}

		items := strings.Split(line, ":")
		if len(items) != 2 {
			// ignore empty lines
			continue
		}
		name, repo := items[0], items[1]

		if _, ok := pluginsMapping[flag][name]; ok {
			log.Fatalf("Duplicate entry %q", name)
		}

		pluginsMapping[flag][name] = pluginPath + repo // Default, unless overridden by 3rd arg

		if _, err := os.Stat(pluginFSPath + repo); err != nil { // External package has been given
			pluginsMapping[flag][name] = repo
		}
	}
	genImports("core/engine/plugin/pluginz.go", "plugin", pluginsMapping)
	genDirectives("core/engine/pluginz.go", "engine", pluginsMapping)
}

func genImports(file, pack string, pluginsMapping map[string]map[string]string) {
	outs := header + "package " + pack + "\n\n" + "import ("

	if pluginCount := len(pluginsMapping["scaler"]) + len(pluginsMapping["metric_provider"]); pluginCount > 0 {
		outs += "\n"
	}

	outs += "// Include all plugins.\n"
	for _, plugins := range pluginsMapping {
		for _, pack := range plugins {
			outs += `_ "` + pack + `"` + "\n"
		}
	}
	outs += ")\n"

	if err := formatAndWrite(file, outs); err != nil {
		log.Fatalf("Failed to format and write: %q", err)
	}
}

func genDirectives(file, pack string, pluginsMapping map[string]map[string]string) {
	outs := `%spackage %s

	var (
		MetricProviders = []string{%s}
	
		Scalers = []string{%s}
	)
`
	var (
		metricProviders []string
		scalers         []string
	)
	for pluginName := range pluginsMapping["metric_provider"] {
		metricProviders = append(metricProviders, `"`+pluginName+`"`)
	}
	for pluginName := range pluginsMapping["scaler"] {
		scalers = append(scalers, `"`+pluginName+`"`)
	}

	if err := formatAndWrite(file, fmt.Sprintf(outs,
		header, pack,
		strings.Join(metricProviders, `,`),
		strings.Join(scalers, ","),
	)); err != nil {
		log.Fatalf("Failed to format and write: %q", err)
	}
}

func formatAndWrite(file string, data string) error {
	res, err := format.Source([]byte(data))
	if err != nil {
		return err
	}

	if err = os.WriteFile(file, res, 0644); err != nil {
		return err
	}
	return nil
}
